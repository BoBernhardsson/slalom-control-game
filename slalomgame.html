<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Slalom Manual Control (Track Authored)</title>
  <style>
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; background:#08101d; color:#e8eefc; }
    header { padding: 12px 16px; display:flex; gap:12px; align-items:center; border-bottom:1px solid #1c2433; background:#0b1324; position:sticky; top:0; z-index:10; flex-wrap:wrap; }
    select, button, input[type="range"] { background:#121a2a; color:#e8eefc; border:1px solid #26324a; border-radius:10px; padding:8px 10px; }
    button { cursor:pointer; }
    main { padding: 12px; display:grid; grid-template-columns: 1.2fr 0.8fr; gap:12px; }
    .card { background:#0f1626; border:1px solid #1c2433; border-radius:16px; padding:12px; box-shadow: 0 10px 20px rgba(0,0,0,.25); }
    canvas { width:100%; height:560px; background:#07101c; border-radius:12px; border:1px solid #1c2433; display:block; }
    .row { display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin-top:10px; }
    .stat { padding:8px 10px; border-radius:12px; background:#0b0f17; border:1px solid #1c2433; }
    .hint { color:#a9b7d3; font-size: 13px; line-height: 1.35; }
    .big { font-size:18px; font-weight:650; }
    .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, monospace; background:#111a2b; border:1px solid #26324a; padding:2px 6px; border-radius:8px; }
    .bar { height:10px; background:#111a2b; border:1px solid #26324a; border-radius:999px; overflow:hidden; }
    .bar > div { height:100%; width:100%; background:#4da3ff; }
    code { background:#0b0f17; border:1px solid #1c2433; padding:2px 6px; border-radius:8px; }
    /* Wind UI */
    .canvasWrap { position: relative; }
    .windAnnounce {
      position: absolute;
      left: 12px;
      top: 12px;
      padding: 8px 10px;
      border-radius: 12px;
      background: rgba(11, 15, 23, 0.75);
      border: 1px solid #26324a;
      color: #e8eefc;
      font-size: 13px;
      opacity: 0;
      transform: translateY(-4px);
      transition: opacity 250ms ease, transform 250ms ease;
      pointer-events: none;
      backdrop-filter: blur(6px);
    }
    .windAnnounce.show { opacity: 1; transform: translateY(0); }

    .windMeter { display:flex; align-items:center; gap:10px; }
    .windBar { position: relative; width: 140px; height: 10px; border-radius: 999px; background:#111a2b; border:1px solid #26324a; overflow:hidden; }
    .windMid { position:absolute; left:50%; top:-2px; width:2px; height:14px; background:#a9b7d3; opacity:0.55; }
    .windPos { position:absolute; left:50%; top:0; height:100%; width:0%; background:#4da3ff; }
    .windNeg { position:absolute; right:50%; top:0; height:100%; width:0%; background:#4da3ff; }
    .windFlash { box-shadow: 0 0 0 2px rgba(232,238,252,0.35); }
  </style>
</head>
<body>
  <header>
    <div class="big">Slalom Manual Control</div>
    <label>Dynamics:
      <select id="system">
        <option value="integrator">Integrator only</option>
        <option value="lag">Integrator + 1st order </option>
        <option value="second">Integrator + 2nd order resonance</option>
        <option value="delay"> Integrator + 1st order + delay </option>
        <option value="non_min_phase">Integrator + Non-min phase</option>
      </select>
    </label>
    <button id="reset">Reset</button>
    <button id="pause">Pause</button>
    <label>Steer u:
      <input id="uSlider" type="range" min="-1" max="1" step="0.01" value="0" style="width:220px"/>
    </label>
    <label>Slope:
      <select id="slopeLevel" style="width:160px">
        <option value="0.25">Green</option>
        <option value="0.5" selected>Blue</option>
        <option value="0.75">Red</option>
        <option value="1.0">Black</option>
      </select>
    </label>
  </header>

  <main>
    <div class="card">
      <div class="canvasWrap">
        <canvas id="scene" width="900" height="900"></canvas>
        <div id="windAnnounce" class="windAnnounce"></div>
      </div>
      <div class="row">
        <div class="stat windMeter">
          Wind: <span class="num windNum" id="windVal">0</span> px/s
          <div id="windBar" class="windBar">
            <div id="windNeg" class="windNeg"></div>
            <div id="windPos" class="windPos"></div>
            <div class="windMid"></div>
          </div>
        </div>

        <div class="stat">Gate #: <span class="num" id="gateVal">0</span></div>
        <div class="stat">Score: <span class="num scoreNum" id="scoreVal">0</span></div>
      </div>
      <div class="hint" style="margin-top:8px;">
        Controls: <span class="kbd">←</span>/<span class="kbd">→</span> (or <span class="kbd">A</span>/<span class="kbd">D</span>) steers,
        <span class="kbd">Space</span> sets u=0. Slider works on mobile.
        <br/>Green flag → pass on the <b>left</b>. Red flag → pass on the <b>right</b>.
      </div>
    </div>

    <div class="card">

      <div class="big" style="margin-top:12px;">Health</div>
      <div class="bar"><div id="healthFill"></div></div>
      <p class="hint" id="sysHint" style="margin-top:10px;"></p>

      <div class="hint">Wind</div>
      <select id="windLevel" style="width:100%">
        <option value="0.1" selected>Breeze</option>
        <option value="0.5">Windy</option>
        <option value="1.0">Storm</option>
      </select>
    </div>
  </main>

<script>
(() => {
  // =========================
  // 1) DEVELOPER SETTINGS
  // =========================


  const DOWNHILL_SPEED = 60;
  const MAX_HORIZONTAL_SPEED = 100; // tune to match your dynamics scale

  // Where the skier sits (near TOP of screen as requested)
  const SKIER_Y_FRAC = 0.12; // 0=top, 1=bottom

  // Skier size scale (smaller than before)
  const SKIER_SCALE = 0.4;

  // Track definition:
  // y = distance down the hill (increasing with time)
  // x = normalized lateral position in [-1, +1]
  // side: green => pass LEFT of pole, red => pass RIGHT of pole
  const TRACK = [
    { y:  300, x: -0.30, side: "green" },
    { y:  540, x:  0.35, side: "red"   },
    { y:  545, x:  0.48, side: "green"   },
    { y:  780, x:  0.10, side: "green" },
    { y: 1020, x: -0.45, side: "red"   },
    { y: 1260, x:  0.50, side: "green" },
    { y: 1500, x:  0.05, side: "red"   },
    { y: 1740, x: -0.20, side: "green" },
    { y: 1980, x:  0.25, side: "red"   },
    { y: 2220, x: -0.55, side: "green" },
    { y: 2460, x:  0.55, side: "red"   },
  ];

  // =========================
  // 2) UI refs
  // =========================
  const canvas = document.getElementById("scene");
  const ctx = canvas.getContext("2d");
  const systemSel = document.getElementById("system");
  const resetBtn = document.getElementById("reset");
  const pauseBtn = document.getElementById("pause");
  const uSlider = document.getElementById("uSlider");
  const slopeLevelSel = document.getElementById("slopeLevel");
  const windLevelSel = document.getElementById("windLevel");

  //const xVal = document.getElementById("xVal");
  //const uVal = document.getElementById("uVal");
  const gateVal = document.getElementById("gateVal");
  const scoreVal = document.getElementById("scoreVal");
  const healthFill = document.getElementById("healthFill");
  const sysHint = document.getElementById("sysHint");
  const windVal = document.getElementById("windVal");
  const windBar = document.getElementById("windBar");
  const windPos = document.getElementById("windPos");
  const windNeg = document.getElementById("windNeg");
  const windAnnounce = document.getElementById("windAnnounce");

  // =========================
  // 3) Helpers
  // =========================
  const dt = 1/60;
  const W = canvas.width, H = canvas.height;
  const skierY = H * SKIER_Y_FRAC;


  // --- Wind as piecewise-constant velocity bias (px/s), updated every Uniform[10,20] seconds ---
  const WIND_MIN_DT = 8;          // seconds
  const WIND_MAX_DT = 15;          // seconds
  const WIND_VMAX_PXPS = 70;       // max |wind bias| when wind slider = 1.0 (tune)
  let simTime = 0;                // seconds since reset
  let windBias = 0;               // px/s (held constant between updates)
  let nextWindChangeT = 0;        // seconds


  // --- Audio: procedural "whoosh" on wind change ---
  let audioCtx = null;
  function ensureAudio() {
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }
  function unlockAudioOnce() {
    try {
      ensureAudio();
      if (audioCtx.state !== "running") audioCtx.resume();
    } catch (_) {}
    window.removeEventListener("pointerdown", unlockAudioOnce);
    window.removeEventListener("keydown", unlockAudioOnce);
  }
  window.addEventListener("pointerdown", unlockAudioOnce, { once: true });
  window.addEventListener("keydown", unlockAudioOnce, { once: true });

  function playWhoosh(intensity01) {
    try {
      ensureAudio();
      if (audioCtx.state !== "running") return; // requires user gesture first
      const t0 = audioCtx.currentTime;
      const dur = 0.5;
      const n = Math.floor(audioCtx.sampleRate * dur);
      const buf = audioCtx.createBuffer(1, n, audioCtx.sampleRate);
      const data = buf.getChannelData(0);
      for (let i = 0; i < n; i++) data[i] = (Math.random() * 2 - 1);

      const src = audioCtx.createBufferSource();
      src.buffer = buf;

      const bp = audioCtx.createBiquadFilter();
      bp.type = "bandpass";
      bp.Q.value = 0.9;
      bp.frequency.setValueAtTime(220, t0);
      bp.frequency.exponentialRampToValueAtTime(1400, t0 + dur);

      const g = audioCtx.createGain();
      const peak = 0.02 + 0.14 * Math.max(0, Math.min(1, intensity01));
      g.gain.setValueAtTime(0.0001, t0);
      g.gain.exponentialRampToValueAtTime(peak, t0 + 0.02);
      g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);

      src.connect(bp);
      bp.connect(g);
      g.connect(audioCtx.destination);
      src.start(t0);
      src.stop(t0 + dur);
    } catch (_) {}
  }

  // --- Gate feedback sounds ---
  function playPositive() {
    try {
      ensureAudio();
      if (audioCtx.state !== "running") return;

      const t0 = audioCtx.currentTime;
      const dur = 0.18;

      const osc = audioCtx.createOscillator();
      osc.type = "sine";
      osc.frequency.setValueAtTime(650, t0);
      osc.frequency.exponentialRampToValueAtTime(1100, t0 + dur);

      const g = audioCtx.createGain();
      g.gain.setValueAtTime(0.0001, t0);
      g.gain.exponentialRampToValueAtTime(0.07, t0 + 0.02);
      g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);

      osc.connect(g);
      g.connect(audioCtx.destination);
      osc.start(t0);
      osc.stop(t0 + dur);
    } catch (_) {}
  }

  function playNegative() {
    try {
      ensureAudio();      
      if (audioCtx.state !== "running") return;

      const t0 = audioCtx.currentTime;      
      const dur = 0.28;

      const osc = audioCtx.createOscillator();
      osc.type = "triangle";
      osc.frequency.setValueAtTime(400, t0);
      osc.frequency.exponentialRampToValueAtTime(140, t0 + dur);

      const g = audioCtx.createGain();
      g.gain.setValueAtTime(0.0001, t0);
      g.gain.exponentialRampToValueAtTime(0.10, t0 + 0.02);      
      g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);

      osc.connect(g);
      g.connect(audioCtx.destination);
      osc.start(t0);
      osc.stop(t0 + dur);
    } catch (_) {}
  }



  let windAnnounceTimer = null;
  function announceWindChange(oldBias, newBias) {
    const dir = newBias > 0 ? "→" : (newBias < 0 ? "←" : "•");
    windAnnounce.textContent = `Wind shift ${dir} ${Math.round(newBias)} px/s`;
    windAnnounce.classList.add("show");
    windBar.classList.add("windFlash");
    if (windAnnounceTimer) clearTimeout(windAnnounceTimer);
    windAnnounceTimer = setTimeout(() => {
      windAnnounce.classList.remove("show");
      windBar.classList.remove("windFlash");
    }, 2500);

    const delta = Math.abs(newBias - oldBias);
    const windLevel = parseFloat(windLevelSel.value) || 0;
    const max = Math.max(1, windLevel * WIND_VMAX_PXPS);
    playWhoosh(Math.min(1, delta / max));
  }


  function clamp(a, lo, hi){ return Math.max(lo, Math.min(hi, a)); }
  function randn() {
    let u1 = Math.random() || 1e-9, u2 = Math.random();
    return Math.sqrt(-2*Math.log(u1))*Math.cos(2*Math.PI*u2);
  }

  function systemDescription(kind){
    switch(kind){
      case "lag": return "Lag: steering feels heavy/sluggish";
      case "integrator": return "Integrator";
      case "second": return "Oscillatory steering";
      case "delay": return "Integrator with delay";
      case "non_min_phase": return "Non-minimum phase";
    }
  }

  // =========================
  // 4) Dynamics (lateral x(t))
  // =========================
  let x = 0;      // pixels (centered)
  let v = 0;      // pixels/s
  let x2 = 0;     // second-order velocity
  let u = 0;
  let y = 0;      // 2nd-order block output
  let ydot = 0;   // derivative of y
  let wAP = 0;    // all-pass internal state for (1 - s*tau)/(1 + s*tau)

  // delay on u
  const delaySec = 0.1;  // seconds of delay (tune this to make it challenging but not impossible)
  const delaySteps = Math.max(1, Math.floor(delaySec/dt));
  let uBuf = new Array(delaySteps).fill(0);

  // --- Ski tracks (history) ---
  const SKI_HALF_GAP = 10 * SKIER_SCALE;   // half distance between skis (px)
  const TRACK_SAMPLE_DS = 8;               // sample every ~8 px of downhill motion
  const TRACK_MAX_POINTS = 2500;           // hard cap for performance
  let skiTrack = [];                       // array of { s: number, x: number }
  let lastTrackSampleS = 0;

  function stepDynamics(kind, uCmd){

    if (kind === "lag") {
      const tau = 0.5, K = 120;
      v += dt * (1/tau)*(-v + K*uCmd);   // no gust for lag (optional, to isolate effect)
      x += dt * v;
    }
    else if (kind === "integrator") {
      const K = 120;
      x += dt * (K*uCmd);
    }
    else if (kind === "second") {      // 2nd-order block: y'' + 2ζωn y' + ωn^2 y = K ωn^2 u
      const wn = 2, zeta = 0.15, K = 120;
      const yddot = -2*zeta*wn*ydot - wn*wn*y + (K*wn*wn)*uCmd;
      ydot += dt * yddot;
      y    += dt * ydot;
      x += dt * y;
    }
    else if (kind === "delay") {
      const tau = 0.6, K = 120;
      uBuf.push(uCmd);
      const uDelayed = uBuf.shift();
      v += dt * (1/tau)*(-v + K*uDelayed);
      x += dt * v;
    }
    else if (kind === "non_min_phase") {
      // Non-minimum-phase integrator:
      // X/U = K/s * (1 - s*tau)/(1 + s*tau)
      const tau = 0.3;   // tune
      const K = 100;      // tune (matches your other K scales)
      wAP += dt * (-(1/tau) * wAP + (1/tau) * uCmd);
      // all-pass output: y/u = (1 - s*tau)/(1 + s*tau)
      const yAP = (-uCmd + 2 * wAP); // add gust if you want
      // integrator: x' = K * yAP
      x += dt * (K * yAP);
    }
  }


  // =========================
  // 5) Track projection & gate checks
  // =========================
  // We keep a "course progress" variable s(t) (pixels of distance along hill).
  // Each gate has a fixed s = TRACK[i].y.
  // On screen, gate's y-screen position is:
  //   y_screen = skierY + (gateS - currentS)
  // So as currentS increases, gates move upward (y decreases).
  let s = 0;             // course progress
  let gateIndex = 0;     // next gate to check
  let score = 0;
  let health = 1.0;
  let paused = false;

  function gateXpixels(xNorm){
    // xNorm in [-1,1] maps to corridor width
    const corridor = W * 0.43;
    return xNorm * corridor;
  }

  function currentSpeed(){
    const factor = parseFloat(slopeLevelSel.value) || 1.0;
    return DOWNHILL_SPEED * factor;
  }

  function checkGate(g){
    const margin = 10; // pixels away from pole (tolerance)
    const poleX = gateXpixels(g.x);
    const ok = (g.side === "green") ? (x < poleX - margin) : (x > poleX + margin);

    if (ok){
      score += 120;
      health = clamp(health + 0.06, 0, 1);
      playPositive();
    } else {
      score -= 200;
      health = clamp(health - 0.18, 0, 1);
      playNegative();
    }
  }

  // =========================
  // 6) Input
  // =========================
  let keyLeft=false, keyRight=false;
  function applyKeys(){
    const rate = 2.0;
    if (keyLeft) u -= rate*dt;
    if (keyRight) u += rate*dt;
    u = clamp(u, -1, 1);
    uSlider.value = u.toFixed(2);
  }
  window.addEventListener("keydown", (ev) => {
    const k = ev.key.toLowerCase();
    if (ev.key === "ArrowLeft" || k === "a") keyLeft = true;
    if (ev.key === "ArrowRight" || k === "d") keyRight = true;
    if (ev.key === " ") { u = 0; uSlider.value = "0"; }
  });
  window.addEventListener("keyup", (ev) => {
    const k = ev.key.toLowerCase();
    if (ev.key === "ArrowLeft" || k === "a") keyLeft = false;
    if (ev.key === "ArrowRight" || k === "d") keyRight = false;
  });
  uSlider.addEventListener("input", () => { u = parseFloat(uSlider.value); });

  // =========================
  // 7) Drawing
  // =========================
  function drawBackground(){
    ctx.fillStyle = "#07101c";
    ctx.fillRect(0,0,W,H);

    // boundaries
    ctx.globalAlpha = 0.35;
    ctx.strokeStyle = "#a9b7d3";
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(W*0.20, 0); ctx.lineTo(W*0.06, H); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(W*0.80, 0); ctx.lineTo(W*0.94, H); ctx.stroke();
    ctx.globalAlpha = 1;
  }

  function drawGate(g){
    const xPole = W/2 + gateXpixels(g.x);
    const yPole = skierY + (g.y - s);

    // only draw if visible-ish
    if (yPole < -120 || yPole > H + 120) return;

    // pole
    ctx.lineWidth = 3;
    ctx.strokeStyle = (g.side === "green") ? "#2bd46f" : "#ff4d4d";
    ctx.beginPath();
    ctx.moveTo(xPole, yPole - 14);
    ctx.lineTo(xPole, yPole + 14);
    ctx.stroke();

    // flag
    ctx.fillStyle = (g.side === "green") ? "#2bd46f" : "#ff4d4d";
    ctx.beginPath();
    if (g.side === "green") {
      ctx.moveTo(xPole, yPole - 22);
      ctx.lineTo(xPole - 10, yPole - 10);
      ctx.lineTo(xPole, yPole + 2);
    } else {
      ctx.moveTo(xPole, yPole - 22);
      ctx.lineTo(xPole + 10, yPole - 10);
      ctx.lineTo(xPole, yPole + 2);
    }
    ctx.closePath();
    ctx.fill();
  }

  // roundRect fallback
  if (!CanvasRenderingContext2D.prototype.roundRect){
    CanvasRenderingContext2D.prototype.roundRect = function(x,y,w,h,r){
      r = Math.min(r, w/2, h/2);
      this.beginPath();
      this.moveTo(x+r, y);
      this.arcTo(x+w, y, x+w, y+h, r);
      this.arcTo(x+w, y+h, x, y+h, r);
      this.arcTo(x, y+h, x, y, r);
      this.arcTo(x, y, x+w, y, r);
      this.closePath();
      return this;
    }
  }

  function drawSkier(){
    const sx = W/2 + x;
    const sy = skierY;

    const scale = SKIER_SCALE;

    // shadow
    ctx.globalAlpha = 0.22;
    ctx.fillStyle = "#000";
    ctx.beginPath();
    ctx.ellipse(sx, sy + 22*scale, 22*scale, 8*scale, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;

    // skis
    ctx.strokeStyle = "#e8eefc";
    ctx.lineWidth = 4*scale;
    ctx.beginPath();
    ctx.moveTo(sx - 14*scale, sy + 14*scale);
    ctx.lineTo(sx - 26*scale, sy + 44*scale);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(sx + 14*scale, sy + 14*scale);
    ctx.lineTo(sx + 26*scale, sy + 44*scale);
    ctx.stroke();

    // body
    ctx.fillStyle = "#4da3ff";
    ctx.beginPath();
    ctx.roundRect(sx - 11*scale, sy - 16*scale, 22*scale, 36*scale, 9*scale);
    ctx.fill();

    // helmet
    ctx.fillStyle = "#e8eefc";
    ctx.beginPath();
    ctx.arc(sx, sy - 24*scale, 8*scale, 0, Math.PI*2);
    ctx.fill();
  }

  function drawHUD(){
    const xNorm = x / (W*0.43);
    //xVal.textContent = xNorm.toFixed(2);
    //uVal.textContent = u.toFixed(2);
    gateVal.textContent = gateIndex.toString();
    scoreVal.textContent = Math.round(score).toString();
    healthFill.style.width = `${Math.round(health*100)}%`;

    // wind meter (px/s + bar)
    windVal.textContent = String(Math.round(windBias));
    const windLevel = parseFloat(windLevelSel.value) || 0;
    const max = Math.max(1, windLevel * WIND_VMAX_PXPS);
    const r = Math.max(-1, Math.min(1, windBias / max)); // normalized to current max
    const wPct = `${Math.abs(r) * 50}%`; // half-bar is 50%
    if (r >= 0) { windPos.style.width = wPct; windNeg.style.width = "0%"; }
    else        { windNeg.style.width = wPct; windPos.style.width = "0%"; }
   }

  function drawSkiTracks(){
    if (skiTrack.length < 2) return;

    // draw two polylines: left ski and right ski
    ctx.globalAlpha = 0.28;
    ctx.strokeStyle = "#e8eefc";
    ctx.lineWidth = 2;

    // Left ski
    ctx.beginPath();
    for (let i = 0; i < skiTrack.length; i++){
      const p = skiTrack[i];
      const yScreen = skierY + (p.s - s);
      if (i === 0) ctx.moveTo(W/2 + (p.x - SKI_HALF_GAP), yScreen);
      else ctx.lineTo(W/2 + (p.x - SKI_HALF_GAP), yScreen);
    }
    ctx.stroke();

    // Right ski
    ctx.beginPath();
    for (let i = 0; i < skiTrack.length; i++){
      const p = skiTrack[i];
      const yScreen = skierY + (p.s - s);
      if (i === 0) ctx.moveTo(W/2 + (p.x + SKI_HALF_GAP), yScreen);
      else ctx.lineTo(W/2 + (p.x + SKI_HALF_GAP), yScreen);
    }
    ctx.stroke();

    ctx.globalAlpha = 1;
  }

  // =========================
  // 8) Reset & loop
  // =========================
  function resetAll(){
    s = 0;
    gateIndex = 0;
    score = 0;
    health = 1.0;

    // wind reset
    simTime = 0;
    windBias = 0;
    nextWindChangeT = (WIND_MIN_DT + Math.random() * (WIND_MAX_DT - WIND_MIN_DT));

    x = 0; v = 0; x2 = 0;
    y = 0; ydot = 0;
    u = 0; uSlider.value = "0";
    uBuf = new Array(delaySteps).fill(0);

    skiTrack = [];
    lastTrackSampleS = 0;

    wAP = 0;

    sysHint.textContent = systemDescription(systemSel.value);
  }

  function tick(){
    if (!paused){
      applyKeys();

      // wind update (piecewise-constant velocity bias)
      simTime += dt;
      if (simTime >= nextWindChangeT) {
        const oldBias = windBias;
        const windLevel = parseFloat(windLevelSel.value); // scales max bias
        const amp = windLevel * WIND_VMAX_PXPS;
        windBias = (Math.random() * 2 - 1) * amp; // Uniform[-amp, +amp] px/s
        nextWindChangeT = simTime + (WIND_MIN_DT + Math.random() * (WIND_MAX_DT - WIND_MIN_DT));
        announceWindChange(oldBias, windBias);
      }


      // dynamics
      stepDynamics(systemSel.value, u);

      // apply wind post-plant (adds lateral velocity bias)
      x += dt * windBias;

      // corridor bound
      const xLim = W*0.43;
      x = clamp(x, -xLim, xLim);

      // advance course progress (downhill depends on horizontal speed)
      const speedMax = currentSpeed();

      // estimate horizontal speed (v exists in lag/delay, but ensure generic)
      let vHoriz = v;

      // for integrator model, v is not used → approximate from last step
      if (systemSel.value === "integrator") {
        // finite difference estimate
        vHoriz = (x - (tick.prevX ?? x)) / dt;
      }

      // for second-order model, x2 is velocity
      if (systemSel.value === "second") {
        vHoriz = x2;
      }

      // Non-minimum phase can be tricky to estimate speed from state → use finite difference
      if (systemSel.value === "non_min_phase") {
        vHoriz = (x - (tick.prevX ?? x)) / dt;
      }

      const reduction = 1 - 0.4 * Math.abs(vHoriz / MAX_HORIZONTAL_SPEED);
      const downhillSpeed = speedMax * clamp(reduction, 0.05, 1);

      s += downhillSpeed * dt;

      // --- record ski track points (downsample by downhill distance) ---
      if ((s - lastTrackSampleS) >= TRACK_SAMPLE_DS) {
        skiTrack.push({ s, x });
        lastTrackSampleS = s;
      }

      // --- cull old points that are far above the screen (and cap length) ---
      // Keep points whose screen y is not too far above the top:
      // yScreen = skierY + (p.s - s)  -> keep if yScreen > -120
      while (skiTrack.length && (skierY + (skiTrack[0].s - s)) < -120) {
        skiTrack.shift();
      }
      if (skiTrack.length > TRACK_MAX_POINTS) {
        skiTrack.splice(0, skiTrack.length - TRACK_MAX_POINTS);
      }

      tick.prevX = x;


      // gate checking: when gate reaches skierY => its y_screen <= skierY
      // i.e. (g.y - s) <= 0  ->  s >= g.y
      while (gateIndex < TRACK.length && s >= TRACK[gateIndex].y){
        checkGate(TRACK[gateIndex]);
        gateIndex += 1;

        if (gateIndex >= TRACK.length){
          // Loop: restart the course and also restart ski tracks sampling
          s = 0;
          gateIndex = 0;

         // IMPORTANT: reset track history & sampling reference so new tracks get recorded
          skiTrack = [];
          lastTrackSampleS = 0;
        }
      }

      // render
      drawBackground();
      drawSkiTracks();
      // draw upcoming gates only (all gates whose y_screen > -some margin)
      for (let i=0;i<TRACK.length;i++){
        // draw a few ahead & behind to keep it cheap
        const yScreen = skierY + (TRACK[i].y - s);
        if (yScreen > -160 && yScreen < H + 160) drawGate(TRACK[i]);
      }
      drawSkier();
      drawHUD();

      if (health <= 0){
        paused = true;
        pauseBtn.textContent = "Resume";
      }
    }
    requestAnimationFrame(tick);
  }

  // UI events
  resetBtn.addEventListener("click", resetAll);
  pauseBtn.addEventListener("click", () => {
    paused = !paused;
    pauseBtn.textContent = paused ? "Resume" : "Pause";
  });
  systemSel.addEventListener("change", () => { sysHint.textContent = systemDescription(systemSel.value); resetAll(); });

  // init
  resetAll();
  tick();
})();
</script>
</body>
</html>