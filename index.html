<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Slalom Manual Control (Track Authored)</title>
  <style>
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; background:#08101d; color:#e8eefc; }
    header { padding: 12px 16px; display:flex; gap:12px; align-items:center; border-bottom:1px solid #1c2433; background:#0b1324; position:sticky; top:0; z-index:10; flex-wrap:wrap; }
    select, button, input[type="range"] { background:#121a2a; color:#e8eefc; border:1px solid #26324a; border-radius:10px; padding:8px 10px; }
    button { cursor:pointer; }
    main { padding: 12px; display:grid; grid-template-columns: 1.2fr 0.8fr; gap:12px; }
    .card { background:#0f1626; border:1px solid #1c2433; border-radius:16px; padding:12px; box-shadow: 0 10px 20px rgba(0,0,0,.25); }
    
    .canvasWrap{
      position: relative;
      width: 100%;
      aspect-ratio: 1 / 1;           /* square playfield */
      max-height: calc(100vh - 170px); /* leave room for header + padding */
    }

    /* Canvas fills the wrapper */
    canvas{
      width:100%;
      height:100%;
      background:#07101c;
      border-radius:12px;
      border:1px solid #1c2433;
      display:block;
    }

    @media (max-width: 900px){
      main{
        grid-template-columns: 1fr;
      }
      #uControl{
        right: 12px;
        bottom: 12px;
      }
    }
    .row { display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin-top:10px; }
    .stat { padding:8px 10px; border-radius:12px; background:#0b0f17; border:1px solid #1c2433; }
    .hint { color:#a9b7d3; font-size: 13px; line-height: 1.35; }
    .big { font-size:18px; font-weight:650; }
    .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, monospace; background:#111a2b; border:1px solid #26324a; padding:2px 6px; border-radius:8px; }
    .bar { height:10px; background:#111a2b; border:1px solid #26324a; border-radius:999px; overflow:hidden; }
    .bar > div { height:100%; width:100%; background:#4da3ff; }
    code { background:#0b0f17; border:1px solid #1c2433; padding:2px 6px; border-radius:8px; }
    /* Wind UI */
    .canvasWrap { position: relative; }
    .windAnnounce {
      position: absolute;
      left: 12px;
      top: 12px;
      padding: 8px 10px;
      border-radius: 12px;
      background: rgba(11, 15, 23, 0.75);
      border: 1px solid #26324a;
      color: #e8eefc;
      font-size: 13px;
      opacity: 0;
      transform: translateY(-4px);
      transition: opacity 250ms ease, transform 250ms ease;
      pointer-events: none;
      backdrop-filter: blur(6px);
    }
    .windAnnounce.show { opacity: 1; transform: translateY(0); }

    .windMeter { display:flex; align-items:center; gap:10px; }
    .windBar { position: relative; width: 140px; height: 10px; border-radius: 999px; background:#111a2b; border:1px solid #26324a; overflow:hidden; }
    .windMid { position:absolute; left:50%; top:-2px; width:2px; height:14px; background:#a9b7d3; opacity:0.55; }
    .windPos { position:absolute; left:50%; top:0; height:100%; width:0%; background:#4da3ff; }
    .windNeg { position:absolute; right:50%; top:0; height:100%; width:0%; background:#4da3ff; }
    .windFlash { box-shadow: 0 0 0 2px rgba(232,238,252,0.35); }
   /* Slope level coloring (colors the selected value) */
    #slopeLevel { font-weight: 650; }
    #slopeLevel.level-green { color: #2bd46f; }
    #slopeLevel.level-blue  { color: #4da3ff; }
    #slopeLevel.level-red   { color: #ff4d4d; }
    #slopeLevel.level-black { color: #ebecef; }

    #uControl{
      position: fixed;
      right: 16px;
      bottom: 16px;
      z-index: 999;              /* above canvas */
      background: rgba(11, 15, 23, 0.75);
      border: 1px solid #26324a;
      border-radius: 14px;
      padding: 10px 12px;
      backdrop-filter: blur(6px);
    }

    /* Subtle corner HUD box */
    .hudBox{
      position:absolute;
      bottom:18px;
      right:12px;
      z-index:20;
      max-width: 320px;
      padding:10px 12px;
      border-radius:10px;
      background: rgba(10,12,16,0.55);
      border: 1px solid rgba(255,255,255,0.12);
      backdrop-filter: blur(4px);
      color: rgba(255,255,255,0.92);
      font: 13px/1.25 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      pointer-events:none; /* won’t steal clicks */
    }

    .hudTitle{
      font-weight: 650;
      letter-spacing: 0.2px;
      margin-bottom: 6px;
      opacity: 0.95;
    }

    .hudMath{
      opacity: 0.92;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }

    .frac{
      display:inline-flex;
      flex-direction:column;
      align-items:stretch;   /* important so the line spans the fraction width */
      vertical-align:middle;
      margin: 0 2px;
    }

    .frac .num, .frac .den{
      padding: 0 2px;
      white-space:nowrap;
      text-align:center;
    }

    .frac .fracbar{
      width:100%;
      border-top: 1px solid #fff; /* simple white line */
      opacity: 0.9;
      margin: 1px 0;
    }

    /* Nice-ish subscripts/superscripts */
    sub{ font-size: 0.8em; vertical-align: -0.2em; }
    sup{ font-size: 0.8em; vertical-align: 0.35em; }

    /* Optional: keep it from feeling “loud” on small screens */
    @media (max-width: 520px){
      .hudBox{ max-width: 240px; font-size: 12px; }
    }

    /* Start overlay: click-to-start + enable sound (Firefox-safe) */
    #startOverlay{
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.35);
      backdrop-filter: blur(4px);
      z-index: 50;            /* above HUD + wind announce */
    }

    #startBtn{
      padding: 10px 14px;
      border-radius: 12px;
      border: 1px solid #26324a;
      background: #121a2a;
      color: #e8eefc;
      font-weight: 650;
      cursor: pointer;
    }

  </style>
</head>
<body>
  <header>
    <div class="big">Slalom Manual Control</div>
    <label>Dynamics:
      <select id="system">
        <option value="integrator">Integrator</option>
        <option value="lag">Integrator + 1st order </option>
        <option value="second">Integrator + 2nd order resonance</option>
        <option value="delay"> Integrator + 1st order + delay </option>
        <option value="non_min_phase">Integrator + RHPL zero</option>
      </select>
    </label>
    <button id="reset">Reset</button>
    <button id="pause">Pause</button>
    <div id="uControl">
      <label>Steer u:
        <input id="uSlider" type="range" min="-1" max="1" step="0.01" value="0" style="width:220px"/>
      </label>
    </div>
    <label>Slope:
      <select id="slopeLevel" style="width:160px">
        <option value="0.25">Green</option>
        <option value="0.5" selected>Blue</option>
        <option value="0.75">Red</option>
        <option value="1.0">Black</option>
      </select>
    </label>

    <label>Wind:
      <select id="windLevel" style="width:140px">
        <option value="0.05" selected>Breeze</option>
        <option value="0.5">Windy</option>
        <option value="1.0">Storm</option>
      </select>
    </label>
  </header>

  <main>
    <div class="card">
      <div class="canvasWrap">
        <canvas id="scene" width="900" height="900"></canvas>
        <div id="windAnnounce" class="windAnnounce"></div>
        <!-- Plant model overlay -->
        <div id="plantOverlay" class="hudBox">
          <div id="plantName" class="hudTitle">Plant</div>
          <div id="plantTF" class="hudMath"></div>
        </div>
        <div id="startOverlay">
          <button id="startBtn">Click to start (enable sound)</button>
        </div>
      </div>

      <div class="row">
        <div class="stat windMeter">
          Wind: <span class="num windNum" id="windVal">0</span> px/s
          <div id="windBar" class="windBar">
            <div id="windNeg" class="windNeg"></div>
            <div id="windPos" class="windPos"></div>
            <div class="windMid"></div>
          </div>
        </div>

        <div class="stat">Gate #: <span class="num" id="gateVal">0</span></div>
        <div class="stat">Score: <span class="num scoreNum" id="scoreVal">0</span></div>
      </div>
      <div class="hint" style="margin-top:8px;">
        Controls: <span class="kbd">←</span>/<span class="kbd">→</span> (or <span class="kbd">A</span>/<span class="kbd">D</span>) steers,
        <span class="kbd">Space</span> sets u=0. Slider works on mobile.
        <br/>Green  and Red poles → pass on the flag side. Beware of wind shifts</b>. 
      </div>
    </div>

    <div class="card">
      <div class="big" style="margin-top:12px;">Health</div>
      <div class="bar"><div id="healthFill"></div></div>
      <p class="hint" id="sysHint" style="margin-top:10px;"></p>
    </div>
  </main>

<script>
(() => {
  // =========================
  // 1) DEVELOPER SETTINGS
  // =========================


  const DOWNHILL_SPEED = 60;
  const MAX_HORIZONTAL_SPEED = 100; // tune to match your dynamics scale

  // Where the skier sits (near TOP of screen as requested)
  const SKIER_Y_FRAC = 0.12; // 0=top, 1=bottom

  // Skier size scale (smaller than before)
  const SKIER_SCALE = 0.3;

  // Track definition:
  // y = distance down the hill (increasing with time)
  // x = normalized lateral position in [-1, +1]
  // side: green => pass LEFT of pole, red => pass RIGHT of pole
  const TRACK = [
    { y:  300, x: -0.30, side: "green" },
    { y:  540, x:  0.35, side: "red"   },
    { y:  545, x:  0.48, side: "green"   },
    { y:  780, x:  0.10, side: "red" },
    { y:  782, x:  0.23, side: "green" },
    { y: 1020, x: -0.45, side: "green"   },
    { y: 1260, x:  0.50, side: "red" },
    { y: 1500, x:  0.10, side: "red"   },
    { y: 1502, x:  0.23, side: "green"   },
    { y: 1740, x: -0.20, side: "green" },
    { y: 1980, x:  0.25, side: "red"   },
    { y: 2220, x: -0.55, side: "green" },
    { y: 2460, x:  0.55, side: "red"   },
  ];

  // Outside-slope penalty (applied per second while outside)
  const OUTSIDE_HEALTH_DRAIN_PER_S = 0.03;   // tune
  const OUTSIDE_SCORE_DRAIN_PER_S  = 60;     // tune (points per second)

  // =========================
  // 2) UI refs
  // =========================
  const canvas = document.getElementById("scene");
  const ctx = canvas.getContext("2d");
  const systemSel = document.getElementById("system");
  const resetBtn = document.getElementById("reset");
  const pauseBtn = document.getElementById("pause");
  const uSlider = document.getElementById("uSlider");
  const slopeLevelSel = document.getElementById("slopeLevel");
  function slopeFactor(){
    return parseFloat(slopeLevelSel?.value ?? "1.0");
  }

  function updateSlopeSelectColor() {
    const v = slopeFactor();
    slopeLevelSel.classList.remove("level-green","level-blue","level-red","level-black");
    if (v === 0.25) slopeLevelSel.classList.add("level-green");
    else if (v === 0.5) slopeLevelSel.classList.add("level-blue");
    else if (v === 0.75) slopeLevelSel.classList.add("level-red");
    else slopeLevelSel.classList.add("level-black");
  }

  slopeLevelSel.addEventListener("change", updateSlopeSelectColor);


  const windLevelSel = document.getElementById("windLevel");

  //const xVal = document.getElementById("xVal");
  //const uVal = document.getElementById("uVal");
  const gateVal = document.getElementById("gateVal");
  const scoreVal = document.getElementById("scoreVal");
  const healthFill = document.getElementById("healthFill");
  const sysHint = document.getElementById("sysHint");
  const windVal = document.getElementById("windVal");
  const windBar = document.getElementById("windBar");
  const windPos = document.getElementById("windPos");
  const windNeg = document.getElementById("windNeg");
  const windAnnounce = document.getElementById("windAnnounce");

  

  // =========================
  // 3) Helpers
  // =========================

  // --- Embedded wind "whoosh" sound ---
  const WIND_WHOOSH_DATA_URI = "data:audio/mp3;base64,SUQzBAAAAAAAIlRTU0UAAAAOAAADTGF2ZjYxLjcuMTAwAAAAAAAAAAAAAAD/4zjAAAAAAAAAAAAASW5mbwAAAA8AAAAXAAAHUAAnJycnMTExMTs7Ozs7RERERE5OTk5YWFhYWGJiYmJsbGxsdnZ2dnaAgICAiYmJiZOTk5OTnZ2dnaenp6exsbGxsbu7u7vExMTEzs7Ozs7Y2NjY4uLi4uzs7Ozs9vb29v////8AAAAATGF2YzYxLjE5AAAAAAAAAAAAAAAAJAKgAAAAAAAAB1DAGN6dAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/4xjEAA1AteABTwABpl+/swIYoIJyKCJDV6vV8eAr47AhjI3nOo1ILmlyeCED8Uo3xc1ot51wk4oImX8f47wDB0f/0NB0r2b/4xjEBg3w3rgBj0gAK5KIs5s7+UCcagXYsSjOo+Lz6jro7gK5hCeqYaQb5uv/wBLoEbfMPH1XP/RxilKd/6nwuTYADU2YRTb/4xjECQ5o8u0ZyBgDO7auXjlXto/GEFHBqYsRGum5hC3GyI9QKILFo4d2qX//r7XUi6nm0Hg9Aj4DnQe/QmCXLQAPl8pIwnr/4xjECg7BRukYMkaDyeaXqR11n37rRgMYkDR4kabCHXWgibOxk/A0BCATsb1iCGlNoYXeFi4LEXuFW/fx3aUC3b+AMDnWEHH/4xjECg3BuwG4GYTCfyJKrtS4eVkYnrCQgjhZpoPsna227JKz2bMMFBLR0MRlO7N1fb2tkWx7sg/pgQCe3iQ4kGZ7ouQdREb/4xjEDgypEumgGwZNLezBz+/rbe76WIWHIr0uRQUgABVW60s3i9P88HqnwwMDjGKfJZmApLsAMOCBiwCGlKDuTOppyiyJEP//4xjEFgxpUwW4GEbC9gcAGVZlEgpZyi+qLdHv/wpE+dUVFXdVJTTZWqVAHLsAKgwpGOwwcUvwbW33a9PsIwgdlY/rP/4gKl3/4xjEHwyZLwG4EMROUd0sydxDQqMD5cMONP0vInl+aVUGmzZTq8MENF6U2ZKZSPs4z6UVIn0s8G+fpYU4m2Gnm0Dam+cLImL/4xjEJwwo7txAM8aHGl5SCJZKnkn36rAAbvyMIQvo96z5TscbHREKLCMC5NcUDQntWhr4qM5cX9S257tZ1f4w+O/a8adT1tD/4xjEMQwA+u2gSNYpFOQAB3+EyRMmxoyftyhqcWez7lW5eeaNCQnoPI9RzofDn7VeGOeesi2x5g+QMIKtpZ1IWQJcuAAyEIT=";

  const dt = 1/60;

  let started = false;

  let W = 900, H = 900;
  let skierY = H * SKIER_Y_FRAC;

  function resizeCanvasToDisplaySize(){
    const rect = canvas.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;

    // Display size in CSS pixels
    const displayW = Math.max(2, Math.round(rect.width));
    const displayH = Math.max(2, Math.round(rect.height));

    // Backing store size in device pixels
    const targetW = Math.round(displayW * dpr);
    const targetH = Math.round(displayH * dpr);

    // Only resize if needed (important for performance)
    if (canvas.width !== targetW || canvas.height !== targetH){
      canvas.width = targetW;
      canvas.height = targetH;

      // Reset then scale so drawing uses CSS pixel coords
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }

    // Always keep simulation geometry in CSS pixels
    W = displayW;
    H = displayH;
    skierY = H * SKIER_Y_FRAC;
  }


  // --- Wind as piecewise-constant velocity bias (px/s), updated every Uniform[10,20] seconds ---
  const WIND_MIN_DT = 10;          // seconds
  const WIND_MAX_DT = 20;         // seconds
  const WIND_VMAX_PXPS = 40;      // max |wind bias| when wind slider = 1.0 (tune)
  let simTime = 0;                // seconds since reset
  let windBias = 0;               // px/s (held constant between updates)
  let nextWindChangeT = 0;        // seconds

  // --- Audio (gate tones via WebAudio + wind whoosh via HTMLAudioElement) ---

  let audioCtx = null;

  function ensureAudio() {
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }

  // One unified unlock that works across Chrome/Firefox/iOS
  let audioUnlocked = false;
  function unlockAudio() {
    try {
      // 1) WebAudio unlock (gate tones, heartbeat)
      ensureAudio();
      if (audioCtx && audioCtx.state !== "running") {
        // In Firefox, resume() must happen during a user gesture
        audioCtx.resume().catch(() => {});
      }

      // Mark unlocked once WebAudio is actually running
      if (audioCtx && audioCtx.state === "running") {
        audioUnlocked = true;
      }

      // 2) Prime the whoosh element (best-effort; may be blocked, that's OK)
      // We try quietly; if blocked it will succeed later when user interacts again.
      if (windWhoosh) {
        const oldVol = windWhoosh.volume;
        windWhoosh.volume = 0.0001; // nearly silent
        const p = windWhoosh.play();
        if (p && typeof p.then === "function") {
          p.then(() => {
            windWhoosh.pause();
            windWhoosh.currentTime = 0;
            windWhoosh.volume = oldVol;
          }).catch(() => {
            windWhoosh.volume = oldVol;
          });
        } else {
          // Older browsers: play() might not return a promise
          windWhoosh.pause();
          windWhoosh.currentTime = 0;
          windWhoosh.volume = oldVol;
        }
      }
    } catch (_) {}
  }

  // Register “gesture” events. Do NOT use {once:true} for WebAudio;
  // Firefox sometimes needs more than one successful gesture to get to "running".
  window.addEventListener("pointerdown", unlockAudio, { passive: true });
  window.addEventListener("mousedown",  unlockAudio, { passive: true });
  window.addEventListener("touchstart", unlockAudio, { passive: true });
  window.addEventListener("keydown",    unlockAudio);

  // --- Embedded wind "whoosh" sound (your data URI above this) ---
  const windWhoosh = new Audio(WIND_WHOOSH_DATA_URI);
  windWhoosh.preload = "auto";

  function playWhoosh(intensity01) {
    try {
      if (!audioUnlocked) unlockAudio();

      const vol = 0.12 + 0.25 * Math.max(0, Math.min(1, intensity01));

      // Create a fresh instance so it can't be cut off by reusing the same element
      const a = windWhoosh.cloneNode(true);
      a.volume = vol;
      a.currentTime = 0;

      // Clean up when finished (important to avoid piling up)
      a.addEventListener("ended", () => {
        try { a.src = ""; } catch (_) {}
      }, { once: true });

      a.play().catch(() => {});
    } catch (_) {}
  }


  // --- Gate feedback sounds ---
  function playPositive() {
    try {
      ensureAudio();
      if (audioCtx.state !== "running") {
        unlockAudio();
        if (audioCtx.state !== "running") return;
      }

      const t0 = audioCtx.currentTime;
      const dur = 0.18;

      const osc = audioCtx.createOscillator();
      osc.type = "triangle";
      osc.frequency.setValueAtTime(650, t0);
      osc.frequency.exponentialRampToValueAtTime(1100, t0 + dur);

      const g = audioCtx.createGain();
      g.gain.setValueAtTime(0.0001, t0);
      g.gain.exponentialRampToValueAtTime(0.12, t0 + 0.015);
      g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);

      osc.connect(g);
      g.connect(audioCtx.destination);
      osc.start(t0);
      osc.stop(t0 + dur);
    } catch (_) {}
  }

  function playNegative() {
    try {
      ensureAudio();      
      if (audioCtx.state !== "running") {
        unlockAudio();
        if (audioCtx.state !== "running") return;
      }

      const t0 = audioCtx.currentTime;      
      const dur = 0.28;

      const osc = audioCtx.createOscillator();
      osc.type = "triangle";
      osc.frequency.setValueAtTime(400, t0);
      osc.frequency.exponentialRampToValueAtTime(140, t0 + dur);

      const g = audioCtx.createGain();
      g.gain.setValueAtTime(0.0001, t0);
      g.gain.exponentialRampToValueAtTime(0.15, t0 + 0.02);      
      g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);

      osc.connect(g);
      g.connect(audioCtx.destination);
      osc.start(t0);
      osc.stop(t0 + dur);
    } catch (_) {}
  }

  // --- Low-health heartbeat ---
  const HEARTBEAT_HEALTH_THRESHOLD = 0.35;
  let nextHeartbeatT = 0; // seconds (uses simTime)

  function playHeartbeat(intensity01) {
    try {
      ensureAudio();
      if (audioCtx.state !== "running") {
        unlockAudio();
        if (audioCtx.state !== "running") return;
      }   

      const t0 = audioCtx.currentTime;
      const dur = 0.12;

      const osc = audioCtx.createOscillator();
      osc.type = "sine";
      osc.frequency.setValueAtTime(75, t0);
      osc.frequency.exponentialRampToValueAtTime(45, t0 + dur);

      const g = audioCtx.createGain();
      const peak = 0.04 + 0.26 * intensity01; // louder as health drops
      g.gain.setValueAtTime(0.0001, t0);
      g.gain.exponentialRampToValueAtTime(peak, t0 + 0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);

      osc.connect(g);
      g.connect(audioCtx.destination);
      osc.start(t0);
      osc.stop(t0 + dur);
    } catch (_) {}
  }

  function heartbeatPeriodSeconds() {
    // Faster when health is lower: ~1.1s at threshold -> ~0.45s near 0
    const h = clamp(health, 0, 1);
    const x = clamp((HEARTBEAT_HEALTH_THRESHOLD - h) / HEARTBEAT_HEALTH_THRESHOLD, 0, 1);
    return 1.10 - 1 * x;
  }


  let windAnnounceTimer = null;
  function announceWindChange(oldBias, newBias) {
    const dir = newBias > 0 ? "→" : (newBias < 0 ? "←" : "•");
    windAnnounce.textContent = `Wind shift ${dir} ${Math.round(newBias)} px/s`;
    windAnnounce.classList.add("show");
    windBar.classList.add("windFlash");
    if (windAnnounceTimer) clearTimeout(windAnnounceTimer);
    windAnnounceTimer = setTimeout(() => {
      windAnnounce.classList.remove("show");
      windBar.classList.remove("windFlash");
    }, 2500);

    const delta = Math.abs(newBias - oldBias);
    const windLevel = parseFloat(windLevelSel.value) || 0;
    const max = Math.max(1, windLevel * WIND_VMAX_PXPS);
    playWhoosh(Math.min(1, delta / max));
  }


  function clamp(a, lo, hi){ return Math.max(lo, Math.min(hi, a)); }
  function randn() {
    let u1 = Math.random() || 1e-9, u2 = Math.random();
    return Math.sqrt(-2*Math.log(u1))*Math.cos(2*Math.PI*u2);
  }

  function systemDescription(kind){
    switch(kind){
      case "lag": return "Lag: steering feels heavy/sluggish";
      case "integrator": return "Integrator";
      case "second": return "Oscillatory steering";
      case "delay": return "Integrator with delay";
      case "non_min_phase": return "Non-minimum phase";
    }
  }

  function slopeBoundsAtY(y){
    const t = y / H; // 0 at top, 1 at bottom
    const left  = (W*0.20) + t * ((W*0.06) - (W*0.20));
    const right = (W*0.80) + t * ((W*0.94) - (W*0.80));
    return { left, right };  
  }
  
  // --- Plant overlay: name + transfer function (lightweight HTML) ---
  const PLANT_OVERLAY = {
    integrator: {
      name: "Integrator",
      tf: `G(s) = <span class="frac">
            <span class="num">K</span>
            <span class="fracbar"></span>
            <span class="den">s</span>
          </span>`
    },
    lag: {
      name: "Integrator + 1st order",
      tf: `G(s) = <span class="frac">
            <span class="num">K</span>
            <span class="fracbar"></span>
            <span class="den">s(1 + s&tau;)</span> 
          </span>`
    },
    second: {
      name: "Integrator + 2nd order resonance",
      tf: `G(s) = <span class="frac">
            <span class="num">K</span>
            <span class="fracbar"></span>
            <span class="den">
              s(1 + 2&zeta;<span class="frac"><span class="num">s</span><span class="fracbar"></span><span class="den">&omega;<sub>n</sub></span></span>
              + (<span class="frac"><span class="num">s</span><span class="fracbar"></span><span class="den">&omega;<sub>n</sub></span></span>)<sup>2</sup>)
            </span>
          </span>`
    },
    delay: {
      name: "Time delay system",
      tf: `G(s) = e<sup>-sL</sup> &nbsp;
          <span class="frac">
            <span class="num">K</span>
            <span class="fracbar"></span>
            <span class="den">1 + s&tau;</span>
          </span>`
    },
    non_min_phase: {
      name: "Integrator + RHP zero",
      tf: `G(s) = K
          <span class="frac">
            <span class="num">1 - s&tau;</span>
            <span class="fracbar"></span>
            <span class="den">s(1 + s&tau;)</span>
          </span>`
    }
  };

  function updatePlantOverlay() {
    const key = systemSel.value;
    const info = PLANT_OVERLAY[key] || { name: "Plant", tf: "" };

    const nameEl = document.getElementById("plantName");
    const tfEl   = document.getElementById("plantTF");
    if (nameEl) nameEl.textContent = info.name;
    if (tfEl) tfEl.innerHTML = info.tf;
  }

  // =========================
  // 4) Dynamics (lateral x(t))
  // =========================
  let x = 0;      // pixels (centered)
  let v = 0;      // pixels/s
  let x2 = 0;     // second-order velocity
  let u = 0;
  let y = 0;      // 2nd-order block output
  let ydot = 0;   // derivative of y
  let wAP = 0;    // all-pass internal state for (1 - s*tau)/(1 + s*tau)

  // delay on u
  const delaySec = 0.5;  // seconds of delay (tune this to make it challenging but not impossible)
  const delaySteps = Math.max(1, Math.floor(delaySec/dt));
  let uBuf = new Array(delaySteps).fill(0);

  // --- Ski tracks (history) ---
  const SKI_HALF_GAP = 10 * SKIER_SCALE;   // half distance between skis (px)
  const TRACK_SAMPLE_DS = 8;               // sample every ~8 px of downhill motion
  const TRACK_MAX_POINTS = 2500;           // hard cap for performance
  let skiTrack = [];                       // array of { s: number, x: number }
  let lastTrackSampleS = 0;

  function stepDynamics(kind, uCmd){

    if (kind === "lag") {
      const tau = 0.5, K = 120;
      v += dt * (1/tau)*(-v + K*uCmd);   // no gust for lag (optional, to isolate effect)
      x += dt * v;
    }
    else if (kind === "integrator") {
      const K = 120;
      x += dt * (K*uCmd);
    }
    else if (kind === "second") {      // 2nd-order block: y'' + 2ζωn y' + ωn^2 y = K ωn^2 u
      const wn = 2, zeta = 0.2, K = 120;
      const yddot = -2*zeta*wn*ydot - wn*wn*y + (K*wn*wn)*uCmd;
      ydot += dt * yddot;
      y    += dt * ydot;
      x += dt * y;
    }
    else if (kind === "delay") {
      const tau = 0.5, K = 120;
      uBuf.push(uCmd);
      const uDelayed = uBuf.shift();
      v += dt * (1/tau)*(-v + K*uDelayed);
      x += dt * v;
    }
    else if (kind === "non_min_phase") {
      // Non-minimum-phase integrator:
      // X/U = K/s * (1 - s*tau)/(1 + s*tau)
      const tau = 0.3;   
      const K = 120;     
      wAP += dt * (-(1/tau) * wAP + (1/tau) * uCmd);
      const yAP = (-uCmd + 2 * wAP); 
      x += dt * (K * yAP);
    }
  }


  // =========================
  // 5) Track projection & gate checks
  // =========================
  // We keep a "course progress" variable s(t) (pixels of distance along hill).
  // Each gate has a fixed s = TRACK[i].y.
  // On screen, gate's y-screen position is:
  //   y_screen = skierY + (gateS - currentS)
  // So as currentS increases, gates move upward (y decreases).
  let s = 0;             // course progress
  let gateIndex = 0;     // next gate to check
  let score = 0;
  let health = 1.0;
  let paused = false;

  function gateXpixels(xNorm){
    // xNorm in [-1,1] maps to corridor width
    const corridor = W * 0.43;
    return xNorm * corridor;
  }

  function currentSpeed(){
    const factor = parseFloat(slopeLevelSel.value) || 1.0;
    return DOWNHILL_SPEED * factor;
  }

  function checkGate(g){
    const margin = 10; // pixels away from pole (tolerance)
    const poleX = gateXpixels(g.x);
    const ok = (g.side === "green") ? (x < poleX - margin) : (x > poleX + margin);
    const m = 0.75 + slopeFactor(); // 1.00 / 1.25 / 1.5 / 1.75
    if (ok){
      score += 120 * m;
      health = clamp(health + 0.05, 0, 1);
      playPositive();
    } else {
      score -= 200 * m;
      health = clamp(health - 0.18, 0, 1);
      playNegative();
    }
  }


  // =========================
  // 6) Input
  // =========================
  let keyLeft=false, keyRight=false;
  function applyKeys(){
    const rate = 2.0;
    if (keyLeft) u -= rate*dt;
    if (keyRight) u += rate*dt;
    u = clamp(u, -1, 1);
    uSlider.value = u.toFixed(2);
  }
  window.addEventListener("keydown", (ev) => {
    const k = ev.key.toLowerCase();
    if (ev.key === "ArrowLeft" || k === "a") keyLeft = true;
    if (ev.key === "ArrowRight" || k === "d") keyRight = true;
    if (ev.key === " ") { u = 0; uSlider.value = "0"; }
  });
  window.addEventListener("keyup", (ev) => {
    const k = ev.key.toLowerCase();
    if (ev.key === "ArrowLeft" || k === "a") keyLeft = false;
    if (ev.key === "ArrowRight" || k === "d") keyRight = false;
  });
  uSlider.addEventListener("input", () => { u = parseFloat(uSlider.value); });

  // =========================
  // 7) Drawing
  // =========================
  function drawBackground(){
    ctx.fillStyle = "#07101c";
    ctx.fillRect(0,0,W,H);

    // boundaries
    ctx.globalAlpha = 0.35;
    ctx.strokeStyle = "#a9b7d3";
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(W*0.20, 0); ctx.lineTo(W*0.06, H); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(W*0.80, 0); ctx.lineTo(W*0.94, H); ctx.stroke();
    ctx.globalAlpha = 1;
  }

  function drawGate(g){
    const xPole = W/2 + gateXpixels(g.x);
    const yPole = skierY + (g.y - s);

    // only draw if visible-ish
    if (yPole < -120 || yPole > H + 120) return;

    // pole
    ctx.lineWidth = 3;
    ctx.strokeStyle = (g.side === "green") ? "#2bd46f" : "#ff4d4d";
    ctx.beginPath();
    ctx.moveTo(xPole, yPole - 14);
    ctx.lineTo(xPole, yPole + 14);
    ctx.stroke();

    // flag
    ctx.fillStyle = (g.side === "green") ? "#2bd46f" : "#ff4d4d";
    ctx.beginPath();
    if (g.side === "green") {
      ctx.moveTo(xPole, yPole - 22);
      ctx.lineTo(xPole - 10, yPole - 10);
      ctx.lineTo(xPole, yPole + 2);
    } else {
      ctx.moveTo(xPole, yPole - 22);
      ctx.lineTo(xPole + 10, yPole - 10);
      ctx.lineTo(xPole, yPole + 2);
    }
    ctx.closePath();
    ctx.fill();
  }

  // roundRect fallback
  if (!CanvasRenderingContext2D.prototype.roundRect){
    CanvasRenderingContext2D.prototype.roundRect = function(x,y,w,h,r){
      r = Math.min(r, w/2, h/2);
      this.beginPath();
      this.moveTo(x+r, y);
      this.arcTo(x+w, y, x+w, y+h, r);
      this.arcTo(x+w, y+h, x, y+h, r);
      this.arcTo(x, y+h, x, y, r);
      this.arcTo(x, y, x+w, y, r);
      this.closePath();
      return this;
    }
  }

  function drawSkier(){
    const sx = W/2 + x;
    const sy = skierY;

    const scale = SKIER_SCALE;

    // shadow
    ctx.globalAlpha = 0.22;
    ctx.fillStyle = "#000";
    ctx.beginPath();
    ctx.ellipse(sx, sy + 22*scale, 22*scale, 8*scale, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;

    // skis
    ctx.strokeStyle = "#e8eefc";
    ctx.lineWidth = 4*scale;
    ctx.beginPath();
    ctx.moveTo(sx - 14*scale, sy + 14*scale);
    ctx.lineTo(sx - 26*scale, sy + 44*scale);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(sx + 14*scale, sy + 14*scale);
    ctx.lineTo(sx + 26*scale, sy + 44*scale);
    ctx.stroke();

    // body
    ctx.fillStyle = "#4da3ff";
    ctx.beginPath();
    ctx.roundRect(sx - 11*scale, sy - 16*scale, 22*scale, 36*scale, 9*scale);
    ctx.fill();

    // helmet
    ctx.fillStyle = "#e8eefc";
    ctx.beginPath();
    ctx.arc(sx, sy - 24*scale, 8*scale, 0, Math.PI*2);
    ctx.fill();
  }

  function drawHUD(){
    const xNorm = x / (W*0.43);
    //xVal.textContent = xNorm.toFixed(2);
    //uVal.textContent = u.toFixed(2);
    gateVal.textContent = gateIndex.toString();
    scoreVal.textContent = Math.round(score).toString();
    healthFill.style.width = `${Math.round(health*100)}%`;

    // wind meter (px/s + bar)
    windVal.textContent = String(Math.round(windBias));
    const windLevel = parseFloat(windLevelSel.value) || 0;
    const max = Math.max(1, windLevel * WIND_VMAX_PXPS);
    const r = Math.max(-1, Math.min(1, windBias / max)); // normalized to current max
    const wPct = `${Math.abs(r) * 50}%`; // half-bar is 50%
    if (r >= 0) { windPos.style.width = wPct; windNeg.style.width = "0%"; }
    else        { windNeg.style.width = wPct; windPos.style.width = "0%"; }
   }

  function drawSkiTracks(){
    if (skiTrack.length < 2) return;

    // draw two polylines: left ski and right ski
    ctx.globalAlpha = 0.28;
    ctx.strokeStyle = "#e8eefc";
    ctx.lineWidth = 2;

    // Left ski
    ctx.beginPath();
    for (let i = 0; i < skiTrack.length; i++){
      const p = skiTrack[i];
      const yScreen = skierY + (p.s - s);
      if (i === 0) ctx.moveTo(W/2 + (p.x - SKI_HALF_GAP), yScreen);
      else ctx.lineTo(W/2 + (p.x - SKI_HALF_GAP), yScreen);
    }
    ctx.stroke();

    // Right ski
    ctx.beginPath();
    for (let i = 0; i < skiTrack.length; i++){
      const p = skiTrack[i];
      const yScreen = skierY + (p.s - s);
      if (i === 0) ctx.moveTo(W/2 + (p.x + SKI_HALF_GAP), yScreen);
      else ctx.lineTo(W/2 + (p.x + SKI_HALF_GAP), yScreen);
    }
    ctx.stroke();

    ctx.globalAlpha = 1;
  }

  function drawOutsideTint(intensity){
    if (intensity <= 0) return;

    const alpha = Math.min(0.35, intensity);  // cap tint strength

    ctx.save();
    ctx.fillStyle = `rgba(180, 0, 0, ${alpha})`;
    ctx.fillRect(0, 0, W, H);
    ctx.restore();
  }

  // =========================
  // 8) Reset & loop
  // =========================
  function resetAll(){
    s = 0;
    gateIndex = 0;
    score = 0;
    health = 1.0;
    nextHeartbeatT = 0;

    // wind reset
    simTime = 0;
    windBias = 0;
    nextWindChangeT = (WIND_MIN_DT + Math.random() * (WIND_MAX_DT - WIND_MIN_DT));

    x = 0; v = 0; x2 = 0;
    y = 0; ydot = 0;
    u = 0; uSlider.value = "0";
    uBuf = new Array(delaySteps).fill(0);

    skiTrack = [];
    lastTrackSampleS = 0;

    wAP = 0;

    sysHint.textContent = systemDescription(systemSel.value);
  }

  const startOverlay = document.getElementById("startOverlay");
  const startBtn = document.getElementById("startBtn");

  startBtn.addEventListener("click", () => {
    unlockAudio();          // this click is a real gesture → Firefox accepts it
    started = true;
    startOverlay.style.display = "none";
  });

  function tick(){
    if (!started) { requestAnimationFrame(tick); return; }
    if (!paused){
      applyKeys();

      // wind update (piecewise-constant velocity bias)
      simTime += dt;
      if (simTime >= nextWindChangeT) {
        const oldBias = windBias;
        const windLevel = parseFloat(windLevelSel.value); // scales max bias
        const amp = windLevel * WIND_VMAX_PXPS;
        windBias = (Math.random() * 2 - 1) * amp; // Uniform[-amp, +amp] px/s
        nextWindChangeT = simTime + (WIND_MIN_DT + Math.random() * (WIND_MAX_DT - WIND_MIN_DT));
        announceWindChange(oldBias, windBias);
      }


      // dynamics
      stepDynamics(systemSel.value, u);

      // apply wind post-plant (adds lateral velocity bias)
      x += dt * windBias;

      // corridor bound
      const xLim = W*0.43;
      x = clamp(x, -xLim, xLim);

     // penalize if skier is outside the ski-area defined by slope lines
      const sx = W/2 + x; // skier screen x
      const b = slopeBoundsAtY(skierY);
      let outsideIntensity = 0;
      if (sx < b.left) {
        outsideIntensity = 0.1 + (b.left - sx) / 300;   // 40px soft ramp
      } else if (sx > b.right) {
        outsideIntensity = 0.1 + (sx - b.right) / 300;
      }

      if (outsideIntensity > 0) {
        health = clamp(health - OUTSIDE_HEALTH_DRAIN_PER_S * dt, 0, 1);
        score -= OUTSIDE_SCORE_DRAIN_PER_S * dt;
      }

      // advance course progress (downhill depends on horizontal speed)
      const speedMax = currentSpeed();

      // estimate horizontal speed (v exists in lag/delay, but ensure generic)
      let vHoriz = v;

      // for integrator model, v is not used → approximate from last step
      if (systemSel.value === "integrator") {
        // finite difference estimate
        vHoriz = (x - (tick.prevX ?? x)) / dt;
      }

      // for second-order model, x2 is velocity
      if (systemSel.value === "second") {
        vHoriz = x2;
      }

      // Non-minimum phase can be tricky to estimate speed from state → use finite difference
      if (systemSel.value === "non_min_phase") {
        vHoriz = (x - (tick.prevX ?? x)) / dt;
      }

      const reduction = 1 - 0.5 * Math.abs(vHoriz / MAX_HORIZONTAL_SPEED);
      const downhillSpeed = speedMax * clamp(reduction, 0.05, 1);

      s += downhillSpeed * dt;

      // --- record ski track points (downsample by downhill distance) ---
      if ((s - lastTrackSampleS) >= TRACK_SAMPLE_DS) {
        skiTrack.push({ s, x });
        lastTrackSampleS = s;
      }

      // --- cull old points that are far above the screen (and cap length) ---
      // Keep points whose screen y is not too far above the top:
      // yScreen = skierY + (p.s - s)  -> keep if yScreen > -120
      while (skiTrack.length && (skierY + (skiTrack[0].s - s)) < -120) {
        skiTrack.shift();
      }
      if (skiTrack.length > TRACK_MAX_POINTS) {
        skiTrack.splice(0, skiTrack.length - TRACK_MAX_POINTS);
      }

      tick.prevX = x;


      // gate checking: when gate reaches skierY => its y_screen <= skierY
      // i.e. (g.y - s) <= 0  ->  s >= g.y
      while (gateIndex < TRACK.length && s >= TRACK[gateIndex].y){
        checkGate(TRACK[gateIndex]);
        gateIndex += 1;

        if (gateIndex >= TRACK.length){
          // Loop: restart the course and also restart ski tracks sampling
          s = 0;
          gateIndex = 0;

         // IMPORTANT: reset track history & sampling reference so new tracks get recorded
          skiTrack = [];
          lastTrackSampleS = 0;
        }
      }

      // heartbeat when health is low
      if (health > 0 && health < HEARTBEAT_HEALTH_THRESHOLD) {
        const h = clamp(health, 0, 1);
        const x = clamp((HEARTBEAT_HEALTH_THRESHOLD - h) / HEARTBEAT_HEALTH_THRESHOLD, 0, 1);
        const curved = x * x;   // same nonlinear mapping

        if (simTime >= nextHeartbeatT) {
          playHeartbeat(curved);
          nextHeartbeatT = simTime + heartbeatPeriodSeconds();
        }
      }

      // render
      drawBackground();
      drawSkiTracks();
      // draw upcoming gates only (all gates whose y_screen > -some margin)
      for (let i=0;i<TRACK.length;i++){
        // draw a few ahead & behind to keep it cheap
        const yScreen = skierY + (TRACK[i].y - s);
        if (yScreen > -160 && yScreen < H + 160) drawGate(TRACK[i]);
      }
      drawSkier();
      drawHUD();

      drawOutsideTint(outsideIntensity);

      if (health <= 0){
        paused = true;
        pauseBtn.textContent = "Resume";
      }
    }const m = slopeFactor(); // 0.25 / 0.5 / 0.75 / 1.0
    requestAnimationFrame(tick);
  }

  // UI events
  resetBtn.addEventListener("click", resetAll);
  pauseBtn.addEventListener("click", () => {
    paused = !paused;
    pauseBtn.textContent = paused ? "Resume" : "Pause";
  });
  systemSel.addEventListener("change", () => {
    sysHint.textContent = systemDescription(systemSel.value);
    updatePlantOverlay();
    resetAll();
  });



  // init
  resizeCanvasToDisplaySize();

  window.addEventListener("resize", () => {
    resizeCanvasToDisplaySize();
  });

  resetAll();
  updateSlopeSelectColor();
  updatePlantOverlay();
  tick();
})();
</script>
</body>
</html>
